- 심층 모델이 강력한 이유 : 사용자 행위, 문제, 문제 해법 지식을 간결하고 유연하게 표현하는 중심 개념과 추상화 때문
- 토의 중 암시적으로 존재하는 개념을 인지하며 모델 내 해당 개념을 명확하게 표현하게 된다.
- 암시적인 개념을 정제되지 않은 형태로 인식하는 것 부터 출발

## 개념 파헤치기
- 🙋‍♂️ 회의에서 개념에 대한 의문점을 정리하고 모델에 영향 미칠만한 내용은 질의를 통해서 구체화하는 과정을 거처야하겠다.
- 주의 신호 : 사용자나 도메인 전문가가 설계상 어디에도 표현돼 있지 않은 어휘를 사용한다. 주의하자.
- 🤔 영어랑 한글의 차이로 ... 회의에서는 한글을 사용하는데 실제 코드에는 영어로 나타난다 이게 약한 인지적 부화를 주는 것 같음

### 어색한 부분을 조사하라
- 설계에서 가장 어색한 부분 조사해라
  - 설명하기 힘들 만큼 복잡한 작업을 수행하는 프로시저
  - 새로운 요구사항 탓에 복잡성이 증가하는 부분

### 예제 - 투자 및 투자수익 추적 애플리케이션
- 🙋‍♂️ 도메인 전문가가 개발에 적극적으로 도움을 주려는 케이스다. 현실에서는 희귀한 케이스
- 개발자가 필요한 개념들을 찾아내고자 문제 도메인을 직접 파헤쳐야만 했다.

### 모순점에 대해 깊이 고민하라
- 양측 주장 모두. 동일한 외부 현실에 적용하는 방법을 숙고하는 과정에서 숨겨져 있던 사실을 밝히는 계기가 마련됨
- 🙋‍♂️ 모순은 한 가지 사실에 대한 다른 체험을 의미하므로, 새로운 사실이 내제되있을 수 있다. 물론 한쪽 말이 그냥 잘못된 경우가 더 많을 것 같다만

### 서적을 참고하라
- 다양한 분야에 대해 근본 개념과 일반적인 통념을 설명하는 책을 찾아볼 수 있다.
- 🤔 더 나은 모델링을 위해서 문제 도메인 서적을 읽은 경험이 있는지? 지금은 어떤지? 읽으면 좋겠다 하는 책은?

### 예제 - 이자 수익 예제 (서적 참고)
- 🙋‍♂️ 도메인 전문가가 개발 프로젝트 지원에 별 관심 없을 때, 흔한 케이스, 도메인 전문가가 돕지않으면 시간은 더 많이 들긴 하겠다.
- 📌 모델러로써 더 나은 모델을 위해서
  - 도메인 전문가와의 회의에 적극 참여 및 질의로 구체화
  - 도메인 이해를 위한 학습 (e.g. 서적)

### 시도하고 또 시도하라
- 모델에 유용한 지식을 발견하기까지 `대화로 표현한 시행착오`를 반복하자. 🙋‍♂️ 대화로 시행착오를 반복한다는 말이 인상적이다.

## 다소 불명확한 개념을 모델링하는 법
- 명사와 동사로 표현되지 않는 다른 중요한 범주, 모델 내 명시적 표현 가능
  - 제약조건
  - 프로세스
  - 명세

### 명시적인 제약조건
- 제약조건 (constraint)
- 객체의 불변식을 만족시키는 방법
  - 로직 안에 조건 로직을 사용해서 보장
  - 조건 로직을 별도의 함수로 분리하여 제약조건에 의도를 드러내는 이름 부여
  - 명시적 객체로 분리하거나, 일련의 객체와 관계의 집합으로 모델링
- 제약조건을 포함한 객체의 설계가 잘못된 조짐 🤔 예시를 생각해보자.
  - 제약조건을 계산하기 위해서 해당 객체에는 필요하지 않은 정보가 필요한 경우 ?
  - 관련 규칙이 여러 객체에 걸쳐 나타나며, 동일한 계층구조에 속하지 않는 객체 간 중복 / 상속 관계 강요 ?
    - 특정한 유저 조건을 만족하지 않는 경우 프로세스 진행 불가한 케이스
  - 구현 단계에서 절차적인 코드에 묻혀 제약조건이 명시적으로 표현되지 않는 경우 ?
    - 다음 예제 참조

### 도메인 객체로서의 프로세스
- 오해 말기 : 절차를 캡슐화해서 절차 대신 객체의 목표나 의도에 관해 생각하게 해야함.
- 도메인에 존재하는 프로세스를 의미한다. 🤔 예를 들면?
  - 해운 시스템 운송 프로세스
  - 프로세스 자체가 업무적인 의미를 나타낸다.
  - SERVICE는 프로세스를 명시적으로 표현하는 한 가지 방법이긴하다. 하지만 복잡한 알고리즘을 캡슐화 하게 된다.
- STRATEGY 표현

## 명세 SPECIFICATION
- 규칙을 도메인 계층 내에 유지할 필요가 있지만, 규칙을 통해 평가하려는 객체에 규칙을 두기에는 적절하지 않다.
  - 🙋‍♂️ AGGREGATE - FACTORY의 관계가 떠오른다. AGGREATE에게 생성의 책임까지 두기에는 적절하지 않았다.
- 논리 프로그래밍과 차이 🤔 논리 프로그래밍?
  - 술어의 조합으로 규칙 개념을 제공
- 🤯 규칙의 다양성과 조합이 도메인 객체 기본 의미보다 방대할 때가 있다. 그렇다고 규칙을 도메인 계층에서 분리하면 도메인 코드는 모델을 표현할 수 없다.
- SPECIFICATION은 
  - 다른 객체에 대한 제약조건을 기술
  - 존재할 수도 하지 않을 수도
- 술어와 유사한 VO를 만들자 SPECIFICATION은 객체가 특정 기준을 만족하는지 판단하는 술어 🙋‍♂️ 명세에 식별성이 필요없으니 VO
- 장점
  - 규칙을 도메인 계층에 유지
  - 객체 활용해서 설계가 모델을 더욱 명확하게 반영

## SPECIFICATION의 적용과 구현
- 객체의 상태를 세 가지 목적으로 명시
  1. 요건 충족하는지 객체 `검증`
  2. 컬렉션 내 객체 `선택`
  3. 요구사항 만족하는 새로운 객체 `생성 명시`

### 검증
- 단순

### 선택 (or 질의)
- 특정한 조건 기반 컬렉션의 일부 선택 🤔 filtering ?
- 🤔 모델의 초점을 잃어버린다 ?
- SPECIFICATION의 모델은 유지하고 싶다 + 관계형 데이터베이스의 능력을 어떻게 활용할까?
- 검증 규칙을 담은 동일한 클래스에 질의문 캡슐화하기 🙋‍♂️ 예전에 스터디에서 다룬 주제랑 비슷하다? 성능 때문에 복잡한 SQL를 작성하는 경우 어떻게 처리?

### 요청 구축(생성)
- 아직 존재하지 않는 갳에 대한 기준을 명시
- 명시한 조건을 만족하는 객체나 객쳬 지합을 새로 만들거나 재구성하는 것이 목적
- 생성과 요구사항의 분리
- 장점
  - 코드에 통찰력을 준다 : 인터페이스에 생성 규칙을 명시적으로 전달받으므로 개발자들은 내부 구현에 상관없이 결과물 예상할 수 있다.
  - 풍부한 API 제공 : 생성과 규칙 전달이 분리되므로, 생성 요청 표현하는 코드(클라이언트 존재)는 더 유연한 인터페이스 얻을 수 있다.
  - 테스트 수월